<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>GPU Shadow + HDRI + GUI</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <!-- core three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/dat.gui.min.js"></script>

  <script>
    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    // Scene
    const scene = new THREE.Scene();

    // Camera
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 2, 5);
    const controls = new THREE.OrbitControls(camera, renderer.domElement);

    // Directional Light
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 5);
    light.castShadow = true;
    light.shadow.mapSize.set(2048, 2048);
    light.shadow.camera.near = 0.5;
    light.shadow.camera.far = 50;
    light.shadow.camera.left = -10;
    light.shadow.camera.right = 10;
    light.shadow.camera.top = 10;
    light.shadow.camera.bottom = -10;
    light.shadow.bias = -0.0001;
    scene.add(light);

    // Ambient Light
    scene.add(new THREE.AmbientLight(0x404040, 0.5));

    // SpotLight
    const spotLight = new THREE.SpotLight(0xffffff, 1);
    spotLight.position.set(2, 5, 2);
    spotLight.castShadow = true;
    spotLight.angle = Math.PI / 6;
    spotLight.penumbra = 0.2;
    scene.add(spotLight);

    // Background
    const textureLoader = new THREE.TextureLoader();
    const bg = textureLoader.load("https://checkki.github.io/381/vvj.jpg");
    scene.background = bg;

    // Ground
    const groundTex = textureLoader.load("https://checkki.github.io/381/ccrv.png");
    groundTex.wrapS = groundTex.wrapT = THREE.RepeatWrapping;
    groundTex.repeat.set(4, 4);

    const planeGeo = new THREE.PlaneGeometry(20, 20);
    const planeMat = new THREE.MeshStandardMaterial({
      map: groundTex,
      roughness: 0.7,
      metalness: 0.2
    });
    const plane = new THREE.Mesh(planeGeo, planeMat);
    plane.rotation.x = -Math.PI / 2;
    plane.receiveShadow = true;
    scene.add(plane);

    // Load Gun Model
    const gunTex = textureLoader.load("https://checkki.github.io/381/Blaster_BlasterPBR_BaseColor.jpeg");
    const gunLoader = new THREE.OBJLoader();
    gunLoader.load("https://checkki.github.io/381/gun_gun.obj", function (object) {
      object.traverse(function (child) {
        if (child.isMesh) {
          child.material = new THREE.MeshStandardMaterial({
            map: gunTex,
            roughness: 0.6,
            metalness: 0.3
          });
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });
      object.position.set(0, 0.5, 0);
      scene.add(object);
    });

    // Load Tree Model → ขยับ + ขยาย
    const treeTex = textureLoader.load("https://checkki.github.io/381/DefaultMaterial_Base_Color.png");
    const treeLoader = new THREE.OBJLoader();
    treeLoader.load("https://checkki.github.io/381/Tree.obj", function (object) {
      object.traverse(function (child) {
        if (child.isMesh) {
          child.material = new THREE.MeshStandardMaterial({
            map: treeTex,
            roughness: 0.6,
            metalness: 0.3
          });
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });
      object.position.set(3, 0.5, 0); // ✅ ขยับต้นไม้ไปด้านข้าง (x = 3)
      object.scale.set(3, 3, 3);     // ✅ ขยายต้นไม้ให้ใหญ่ขึ้น
      scene.add(object);
    });

    // HDRI Environment
    const pmrem = new THREE.PMREMGenerator(renderer);
    new THREE.RGBELoader()
      .setDataType(THREE.UnsignedByteType)
      .load("https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/venice_sunset_1k.hdr", function (hdrEquirect) {
        const envMap = pmrem.fromEquirectangular(hdrEquirect).texture;
        scene.environment = envMap;
        hdrEquirect.dispose();
      });

    // dat.GUI Controls
    const gui = new dat.GUI();

    const lightFolder = gui.addFolder("Directional Light");
    lightFolder.add(light, "intensity", 0, 2, 0.1);
    lightFolder.add(light.position, "x", -10, 10, 0.1);
    lightFolder.add(light.position, "y", 0, 20, 0.1);
    lightFolder.add(light.position, "z", -10, 10, 0.1);

    const spotFolder = gui.addFolder("Spot Light");
    spotFolder.add(spotLight, "intensity", 0, 2, 0.1);
    spotFolder.add(spotLight, "angle", 0, Math.PI / 2, 0.01);
    spotFolder.add(spotLight.position, "x", -10, 10, 0.1);
    spotFolder.add(spotLight.position, "y", 0, 20, 0.1);
    spotFolder.add(spotLight.position, "z", -10, 10, 0.1);

    gui.add(plane.material, "roughness", 0, 1, 0.01);
    gui.add(plane.material, "metalness", 0, 1, 0.01);

    // Animate
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    // Resize
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>

</html>
